// SPDX-License-Identifier: MIT â€” See LICENSE for full terms
// Created by Patrick Woo, 2025.
// This file is part of the FPS-R (Frame-Persistent Stateless Randomisation) project.
// https://github.com/patwooky/fpsr
//
// VEX Porting Notes:
// - All C-style casts like (int)value have been converted to VEX-style casts: int(value).
// - All C-style casts like (float)value have been converted to VEX-style casts: float(value).
// - Redundant floor() calls in wrapper functions when passing floats to base functions have been removed.
// - The _get_sine_from_lod_lut function was refactored to be more VEX-idiomatic, avoiding
//   passing arrays as arguments and instead using the `lut_size` to select the correct global LUT.

/**
 * @file fpsr_algorithms_wrap.vex
 * @brief This file demonstrates a wrapper-based approach for getting rich metadata
 * from the core FPS-R algorithms, corrected for VEX compatibility.
 * @details This implementation separates the pure, stateless algorithms from the
 * functions that gather detailed metadata. The wrapper functions perform a robust,
 * two-phase search (exponential probe + binary search) to populate the FPSR_Output struct.
 * This method is highly efficient and avoids "false positive" value collisions.
 */

// VEX does not support #include - math functions are built-in

// Define the global inflation factor for absolute determinism
// This factor scales the 'frame' input to a high-resolution integer timeline.
// All time-based parameters (durations, offsets) must be scaled by this factor
// internally within the base algorithms. Frequencies must be deflated by it.
float FPSR_INFLATION_FACTOR = 100000000.0; // 10^8 for 8 decimal places of precision

// Define the sizes of the sine lookup tables for different LODs
int SINE_LUT_SIZE_100 = 100;
int SINE_LUT_SIZE_500 = 500;
int SINE_LUT_SIZE_1000 = 1000;
int SINE_LUT_SIZE_4096 = 4096; // Highest precision default

// Global constant for 2*PI (float precision in VEX)
float TWO_PI = 6.28318530718;

// Global sine lookup tables
float _sine_lut_100[100];
float _sine_lut_500[500];
float _sine_lut_1000[1000];
float _sine_lut_4096[4096];

// Flag to track if LUTs are initialized
int _luts_initialized = 0;

// Function to initialize all sine lookup tables
// THIS FUNCTION MUST BE CALLED ONCE AT PROGRAM STARTUP!
void initialize_sine_luts() {
    if (_luts_initialized) return; // Only initialize once

    for (int i = 0; i < SINE_LUT_SIZE_100; ++i) {
        _sine_lut_100[i] = sin(float(i) / SINE_LUT_SIZE_100 * TWO_PI);
    }
    for (int i = 0; i < SINE_LUT_SIZE_500; ++i) {
        _sine_lut_500[i] = sin(float(i) / SINE_LUT_SIZE_500 * TWO_PI);
    }
    for (int i = 0; i < SINE_LUT_SIZE_1000; ++i) {
        _sine_lut_1000[i] = sin(float(i) / SINE_LUT_SIZE_1000 * TWO_PI);
    }
    for (int i = 0; i < SINE_LUT_SIZE_4096; ++i) {
        _sine_lut_4096[i] = sin(float(i) / SINE_LUT_SIZE_4096 * TWO_PI);
    }
    _luts_initialized = 1;
}

// VEX-compatible helper function to get sine value from a specific LUT
float _get_sine_from_lod_lut(float phase; int lut_size) {
    if (!_luts_initialized) {
        // Fallback or error if LUTs not initialized.
        // For absolute determinism, this should ideally not happen in production.
        // For now, we'll fall back to standard sin() with a warning.
        printf("WARNING: Sine LUTs not initialized. Falling back to sin(). Call initialize_sine_luts() once.\n");
        return sin(phase);
    }

    // Wrap phase to 0 to 2*PI range
    phase = phase % TWO_PI;
    if (phase < 0) phase += TWO_PI; // Ensure positive for fmod results

    // Map phase to LUT index range
    float fractional_index = phase / TWO_PI * lut_size;

    // Get integer part and fractional part
    int index1 = int(floor(fractional_index));
    float frac = fractional_index - index1;

    // Handle wrap-around for index2 (last point wraps to first)
    int index2 = (index1 + 1) % lut_size;

    // Linear interpolation
    // Select the appropriate global LUT based on lut_size and interpolate
    if (lut_size == SINE_LUT_SIZE_100) {
        return _sine_lut_100[index1] * (1.0 - frac) + _sine_lut_100[index2] * frac;
    } else if (lut_size == SINE_LUT_SIZE_500) {
        return _sine_lut_500[index1] * (1.0 - frac) + _sine_lut_500[index2] * frac;
    } else if (lut_size == SINE_LUT_SIZE_1000) {
        return _sine_lut_1000[index1] * (1.0 - frac) + _sine_lut_1000[index2] * frac;
    } else { // Default to 4096
        return _sine_lut_4096[index1] * (1.0 - frac) + _sine_lut_4096[index2] * frac;
    }
}

/******************************************************************************/
/* Core Components (Struct and portable_rand)                                 */
/******************************************************************************/

// A simple, portable pseudo-random number generator that takes an integer seed.
// Internal calculations use float for higher precision, result is float.
// Now uses the global sine lookup table for absolute determinism.
float portable_rand(int seed) {
    float val = float(seed) * 12.9898;
    val = val % TWO_PI;
    if (val < 0) val += TWO_PI;
    
    // Use the highest precision LUT for sine calculation for absolute determinism
    // This ensures portable_rand's output is consistent across all LOD choices.
    float result_sin = _get_sine_from_lod_lut(val, SINE_LUT_SIZE_4096);
    float result = result_sin * 43758.5453;
    return (result - floor(result)); // Use floor (float version), return as float
}

/******************************************************************************/
/* FPS-R Output Structure                                                     */
/******************************************************************************/
/** This structure holds the output of the FPS-R algorithms.
* The LOD (Level of Detail) determines the computational overhead and the amount of information returned.
* This structure is designed to be flexible and can be extended in the future.
*
* Different LODs will return different sets of fields:
* - LOD 0: randVal
* - LOD 1: randVal, has_changed
* - LOD 2: randVal, has_changed, hold_progress, last_changed_frame, next_changed_frame,
* randVal_next_changed_frame, randStreams[2], selected_stream (for QS algorithm)
* Note: All fields will be set to 0 if the LOD is not applicable.
*
* The fields are:
* float randVal: LOD 0, 1, 2. The random value generated by the FPS-R algorithm.
* int has_changed: LOD 1, 2. A flag indicating whether randVal has changed from the previous frame.
* float hold_progress: LOD 2. The progress of the hold duration, normalised to [0, 1].
* int last_changed_frame: LOD 2. The precise frame (integer) when the random value last changed.
* int next_changed_frame: LOD 2. The precise frame (integer) when the random value will next change.
* float randVal_next_changed_frame: LOD 2. The value that the algorithm will jump to at next_changed_frame.
* float randStreams[2]: LOD 2. (Exclusive to QS) The raw values of stream1_float and stream2_float.
* int selected_stream: LOD 2. (Exclusive to QS) The index of the stream (0 for stream1, 1 for stream2) that was selected by the algorithm.
*/
struct FPSR_Output {
    float randVal;
    int has_changed;
    float hold_progress;
    int last_changed_frame;
    int next_changed_frame;
    float randVal_next_changed_frame;
    float randStreams[2]; // For QS details
    int selected_stream; // For QS details
};

// Using dicts in place of structs in Houdini 19.5 
// structs can be declared in VEX #include but not directly in wrangle snippets
dict FPSR_Output_Dict_Template;
FPSR_Output_Dict_Template['randVal'] = 0.0;
FPSR_Output_Dict_Template['has_changed'] = int(0);
FPSR_Output_Dict_Template['hold_progress'] = 0.0;
FPSR_Output_Dict_Template['last_changed_frame'] = int(0);
FPSR_Output_Dict_Template['next_changed_frame'] = int(0);
FPSR_Output_Dict_Template['randVal_next_changed_frame'] = 0.0;
float streamArr[] = array(0, 0); // Initialise streamArr first then assign to dict
FPSR_Output_Dict_Template['randStreams'] = streamArr; // for fpsr_qs
FPSR_Output_Dict_Template['selected_stream'] = 0; // for fpsr_qs
// querying and updating array values from the dict requires an intermediate variable
// query: float tempArr[] = FPSR_Output_Dict['randStreams'];
// update: tempArr[0] = newVal; FPSR_Output_Dict['randStreams'] = tempArr;
// querying non-array values is direct: int tempInt = FPSR_Output_Dict['has_changed'];
// updating non-array values is direct: FPSR_Output_Dict['has_changed'] = newVal;

// Internal struct for _fpsr_qs_base to return multiple values
struct _FPSR_QS_Base_Output {
    float randVal;
    float stream1_val;
    float stream2_val;
    int selected_stream_idx; // 0 for stream1, 1 for stream2
};

/******************************************************************************/
/* Untouched, Low-Level FPS-R Algorithms                                      */
/******************************************************************************/
// These functions remain pure, returning only a single float value.

float _fpsr_sm_base(
    float frame_input_from_wrapper, // frame is now a float from wrapper
    int minHold, int maxHold,
    int reseedInterval, int seedInner, int seedOuter, int finalRandSwitch)
{
    // Convert scaled float frame to large integer for pure integer math
    // This ensures bit-for-bit determinism for all modulo operations.
    int int_frame = int(floor(frame_input_from_wrapper * FPSR_INFLATION_FACTOR));

    // Scale all time-based integer parameters to match the int_frame resolution
    // These are now 'internal_' variables and replace the direct use of input parameters
    int internal_minHold = int(floor(minHold * FPSR_INFLATION_FACTOR));
    int internal_maxHold = int(floor(maxHold * FPSR_INFLATION_FACTOR));
    int internal_reseedInterval = int(floor(reseedInterval * FPSR_INFLATION_FACTOR));
    int internal_seedInner = int(floor(seedInner * FPSR_INFLATION_FACTOR));
    int internal_seedOuter = int(floor(seedOuter * FPSR_INFLATION_FACTOR));

    if (internal_reseedInterval < int(floor(1.0 * FPSR_INFLATION_FACTOR))) { internal_reseedInterval = int(floor(1.0 * FPSR_INFLATION_FACTOR)); }
    // Use int_frame for modulo operations
    float rand_for_duration_seed_float = float(internal_seedInner) + int_frame - (int_frame % internal_reseedInterval);
    float rand_for_duration = portable_rand(int(floor(rand_for_duration_seed_float)));

    int holdDuration = int(floor(internal_minHold + rand_for_duration * (internal_maxHold - internal_minHold)));
    if (holdDuration < int(floor(1.0 * FPSR_INFLATION_FACTOR))) { holdDuration = int(floor(1.0 * FPSR_INFLATION_FACTOR)); }

    // Use int_frame for modulo operations
    float held_integer_state_float = float(internal_seedOuter) + int_frame - (float(internal_seedOuter + int_frame) % float(holdDuration)); // Explicit integer modulo for absolute determinism
    int held_integer_state = int(floor(held_integer_state_float));

    if (finalRandSwitch) {
        return portable_rand(held_integer_state); // Seed is already large integer
    }
    return float(held_integer_state);
}

float _fpsr_tm_base(
    float frame_input_from_wrapper; // frame is now float from wrapper
    int periodA; int periodB;
    int periodSwitch; int seedInner; int seedOuter; int finalRandSwitch)
{
    // Convert scaled float frame to large integer for pure integer math
    int int_frame = int(floor(frame_input_from_wrapper * FPSR_INFLATION_FACTOR));

    // Scale all time-based integer parameters to match the int_frame resolution
    // These are now 'internal_' variables and replace the direct use of input parameters
    int internal_periodA = int(floor(periodA * FPSR_INFLATION_FACTOR));
    int internal_periodB = int(floor(periodB * FPSR_INFLATION_FACTOR));
    int internal_periodSwitch = int(floor(periodSwitch * FPSR_INFLATION_FACTOR));
    int internal_seedInner = int(floor(seedInner * FPSR_INFLATION_FACTOR));
    int internal_seedOuter = int(floor(seedOuter * FPSR_INFLATION_FACTOR));

    if (internal_periodSwitch < int(floor(1.0 * FPSR_INFLATION_FACTOR))) { internal_periodSwitch = int(floor(1.0 * FPSR_INFLATION_FACTOR)); }
    
    int holdDuration;
    // Use int_frame for modulo operations
    if ((int_frame % internal_periodSwitch) < (internal_periodSwitch / 2)) { // Pure integer modulo
        holdDuration = internal_periodA;
    } else {
        holdDuration = internal_periodB;
    }
    if (holdDuration < int(floor(1.0 * FPSR_INFLATION_FACTOR))) { holdDuration = int(floor(1.0 * FPSR_INFLATION_FACTOR)); }
    
    // Use int_frame for modulo operations
    float held_integer_state_float = float(internal_seedOuter + int_frame) - (float(internal_seedOuter + int_frame) % float(holdDuration)); // Explicit integer modulo for absolute determinism
    int held_integer_state = int(floor(held_integer_state_float));

    if (finalRandSwitch) {
        return portable_rand(held_integer_state); // Seed is already large integer
    }
    return float(held_integer_state);
}

_FPSR_QS_Base_Output _fpsr_qs_base( // Return type changed to _FPSR_QS_Base_Output
    float frame_input_from_wrapper; // frame is now float from wrapper
    float baseWaveFreq; float stream2FreqMult;
    int quantLevelsMinMax[]; int streamsOffset[]; int quantOffsets[];
    int streamSwitchDur; int stream1QuantDur; int stream2QuantDur; int finalRandSwitch;
    int sine_lod_level) // New parameter for sine LOD
{
    _FPSR_QS_Base_Output output; // Initialize output struct
    output.randVal = 0.0;
    output.stream1_val = 0.0;
    output.stream2_val = 0.0;
    output.selected_stream_idx = 0;

    // Convert scaled float frame to large integer for pure integer math
    int int_frame = int(floor(frame_input_from_wrapper * FPSR_INFLATION_FACTOR));

    // Scale all time-based integer parameters to match the int_frame resolution
    // These are now 'internal_' variables and replace the direct use of input parameters
    int internal_streamSwitchDur = int(floor(streamSwitchDur * FPSR_INFLATION_FACTOR));
    int internal_stream1QuantDur = int(floor(stream1QuantDur * FPSR_INFLATION_FACTOR));
    int internal_stream2QuantDur = int(floor(stream2QuantDur * FPSR_INFLATION_FACTOR));
    int internal_streamsOffset_0 = int(floor(streamsOffset[0] * FPSR_INFLATION_FACTOR));
    int internal_streamsOffset_1 = int(floor(streamsOffset[1] * FPSR_INFLATION_FACTOR));
    int internal_quantOffsets_0 = int(floor(quantOffsets[0] * FPSR_INFLATION_FACTOR));
    int internal_quantOffsets_1 = int(floor(quantOffsets[1] * FPSR_INFLATION_FACTOR));

    if (internal_streamSwitchDur < int(floor(1.0 * FPSR_INFLATION_FACTOR))) { internal_streamSwitchDur = int(floor(1.0 * FPSR_INFLATION_FACTOR)); }
    if (internal_stream1QuantDur < int(floor(1.0 * FPSR_INFLATION_FACTOR))) { internal_stream1QuantDur = int(floor(1.0 * FPSR_INFLATION_FACTOR)); }
    if (internal_stream2QuantDur < int(floor(1.0 * FPSR_INFLATION_FACTOR))) { internal_stream2QuantDur = int(floor(1.0 * FPSR_INFLATION_FACTOR)); }

    int quant_min = quantLevelsMinMax[0];
    int quant_max = quantLevelsMinMax[1];
    int quant_range = quant_max - quant_min + 1;
    if (quant_range < 1) quant_range = 1;

    // Use int_frame for modulo operations
    float s1_quant_seed_float = float(internal_quantOffsets_0) + int_frame - (int_frame % internal_stream1QuantDur);
    int s1_quant_level = quant_min + int(floor(portable_rand(int(floor(s1_quant_seed_float))) * quant_range));

    float s2_quant_seed_float = float(internal_quantOffsets_1) + int_frame - (int_frame % internal_stream2QuantDur);
    int s2_quant_level = quant_min + int(floor(portable_rand(int(floor(s2_quant_seed_float))) * quant_range));

    if (s1_quant_level < 1) { s1_quant_level = 1; }
    if (s2_quant_level < 1) { s2_quant_level = 1; }

    if (stream2FreqMult <= 0) { stream2FreqMult = 3.7; } // Still a float input

    // Frequencies must be deflated to match the inflated int_frame resolution
    float deflated_baseWaveFreq = baseWaveFreq / FPSR_INFLATION_FACTOR;
    // stream2FreqMult is a multiplier to deflated_baseWaveFreq
    float deflated_stream2FreqMult_applied = deflated_baseWaveFreq * stream2FreqMult;

    float stream1_raw_sine, stream2_raw_sine; // Declare variables for raw sine values
    int lut_size;

    // Select sine generation method based on sine_lod_level
    if (sine_lod_level == 0) {
        // Direct sin() call (float precision)
        stream1_raw_sine = sin((float(internal_streamsOffset_0) + int_frame) * deflated_baseWaveFreq);
        stream2_raw_sine = sin((float(internal_streamsOffset_1) + int_frame) * deflated_stream2FreqMult_applied);
    }
    else {
        // Select correct LUT size based on LOD level
        if (sine_lod_level == 1) lut_size = SINE_LUT_SIZE_100;
        else if (sine_lod_level == 2) lut_size = SINE_LUT_SIZE_500;
        else if (sine_lod_level == 3) lut_size = SINE_LUT_SIZE_1000;
        else lut_size = SINE_LUT_SIZE_4096; // Default to highest precision LUT if invalid LOD is provided
        
        stream1_raw_sine = _get_sine_from_lod_lut((float(internal_streamsOffset_0) + int_frame) * deflated_baseWaveFreq, lut_size);
        stream2_raw_sine = _get_sine_from_lod_lut((float(internal_streamsOffset_1) + int_frame) * deflated_stream2FreqMult_applied, lut_size);
    }
    
    output.stream1_val = floor(stream1_raw_sine * s1_quant_level) / float(s1_quant_level);
    output.stream2_val = floor(stream2_raw_sine * s2_quant_level) / float(s2_quant_level);

    // Use frame for modulo operation
    output.selected_stream_idx = ((int_frame % internal_streamSwitchDur) < (internal_streamSwitchDur / 2)) ? 0 : 1;
    
    float active_stream_val_float = (output.selected_stream_idx == 0) ? output.stream1_val : output.stream2_val;

    if (finalRandSwitch == 1) {
        output.randVal = portable_rand(int(active_stream_val_float * FPSR_INFLATION_FACTOR)); // Seed is already large integer
    } else {
        output.randVal = float(0.5 * active_stream_val_float + 0.5); // Return float, calculations in float
    }
    return output;
}

/******************************************************************************/
/* High-Level Wrapper Functions with Robust Search                            */
/******************************************************************************/

/**
 * @brief Wrapper for fpsr_sm that returns a detailed FPSR_Output struct.
 * @param frame (int) The current frame or time input.
 * @param frame_multiplier (float) A float value to scale the frame input, effectively speeding
 * up or slowing down the algorithm's internal timeline.
 * @param minHold (int) The minimum duration (in frames) for a value to hold.
 * @param maxHold (int) The maximum duration (in frames) for a value to hold.
 * @param reseedInterval (int) The fixed interval at which a new hold duration is calculated.
 * @param seedInner (int) An offset for the random duration calculation to create unique sequences.
 * @param seedOuter (int) An offset for the final value calculation to create unique sequences.
 * @param finalRandSwitch (int) A flag that can turn off the final randomisation step.
 * @param lod (int) The level of detail to calculate.
 * @param max_search_frames (int) A safety limit for the backward/forward search to prevent infinite loops.
 * @return FPSR_Output struct with metadata populated based on the LOD.
 */
FPSR_Output fpsr_sm_get_details(
    int frame; float frame_multiplier; // Reordered frame_multiplier
    int minHold; int maxHold;
    int reseedInterval; int seedInner; int seedOuter; int finalRandSwitch;
    int lod; int max_search_frames)
{
    FPSR_Output out;
    out.randVal = 0.0;
    out.has_changed = 0;
    out.hold_progress = 0.0;
    out.last_changed_frame = 0;
    out.next_changed_frame = 0;
    out.randVal_next_changed_frame = 0.0;
    out.randStreams[0] = 0.0;
    out.randStreams[1] = 0.0;
    out.selected_stream = 0;

    // Calculate the scaled frame input for the base algorithm (as float)
    float current_scaled_frame_float = float(frame) * frame_multiplier;

    // LOD 0: Get current value.
    out.randVal = _fpsr_sm_base(current_scaled_frame_float, minHold, maxHold, reseedInterval, seedInner, seedOuter, finalRandSwitch);

    if (lod < 1) return out;

    // LOD 1: Compare with previous frame to check for change.
    // Calculate the scaled frame input for the previous frame
    float prev_scaled_frame_for_lod1_float = float(frame - 1) * frame_multiplier;
    float prev_val = _fpsr_sm_base(prev_scaled_frame_for_lod1_float, minHold, maxHold, reseedInterval, seedInner, seedOuter, finalRandSwitch);
    out.has_changed = (out.randVal != prev_val);

    if (lod < 2) return out;

    // LOD 2: Use a robust two-phase search to find change frames.
    int low_int, high_int, mid_int, result_int;
    float next_val_candidate = 0.0; // Stores the value at the next_changed_frame

    // --- Backwards Search for last_changed_frame ---
    if (out.has_changed) {
        // Optimization: If has_changed == 1, assign last_changed_frame = frame.
        // Avoids 4 calls to _fpsr_xx_base(): (1 in exponential probe, 3 in binary search)
        // Avoids 3 loops iterations (1 in exponential probe, 2 in binary search)
        out.last_changed_frame = frame;
    } else {
        // Phase 1: Exponential probe to find a "dirty" region.
        int bound_low_int = frame; // operates on original frame space (int)
        int step_int = 1; // Used for exponential probe step
        while (frame - step_int > frame - max_search_frames) {
            // Scale the probe frame (as float) before passing to base algorithm
            float probe_frame_float = float(frame - step_int) * frame_multiplier;
            float val_at_probe = _fpsr_sm_base(probe_frame_float, minHold, maxHold, reseedInterval, seedInner, seedOuter, finalRandSwitch);
            if (val_at_probe != out.randVal) {
                bound_low_int = frame - step_int;
                break;
            }
            bound_low_int = frame - step_int;
            step_int *= 2;
        }
        
        // Phase 2: Binary search within the safe, "dirty" region.
        low_int = bound_low_int;
        high_int = frame;
        result_int = frame; // result stores the original frame number (int)
        while(low_int <= high_int) {
            mid_int = low_int + (high_int - low_int) / 2;
            // Scale the mid frame (as float) before passing to base algorithm
            float mid_frame_float = float(mid_int) * frame_multiplier;
            if (_fpsr_sm_base(mid_frame_float, minHold, maxHold, reseedInterval, seedInner, seedOuter, finalRandSwitch) == out.randVal) {
                // Check the frame immediately preceding 'mid' in the scaled timeline
                // using 1 as the step for comparison
                float mid_minus_step_frame_float = float(mid_int - 1) * frame_multiplier;
                if (_fpsr_sm_base(mid_minus_step_frame_float, minHold, maxHold, reseedInterval, seedInner, seedOuter, finalRandSwitch) != out.randVal) {
                    result_int = mid_int; break;
                }
                high_int = mid_int - 1;
            } else {
                low_int = mid_int + 1;
            }
        }
        out.last_changed_frame = result_int;
    }

    // --- Forwards Search for next_changed_frame ---
    // Phase 1: Exponential probe.
    int bound_high_int = frame; // operates on original frame space (int)
    int step_int = 1; // Used for exponential probe step
    while (frame + step_int < frame + max_search_frames) {
        // Scale the probe frame (as float) before passing to base algorithm
        float probe_frame_float = float(frame + step_int) * frame_multiplier;
        float val_at_probe = _fpsr_sm_base(probe_frame_float, minHold, maxHold, reseedInterval, seedInner, seedOuter, finalRandSwitch);
        if (val_at_probe != out.randVal) {
            bound_high_int = frame + step_int;
            next_val_candidate = val_at_probe; // Store the value at the first differing frame
            break;
        }
        bound_high_int = frame + step_int;
        step_int *= 2;
    }

    // Phase 2: Binary search.
    low_int = frame;
    high_int = bound_high_int;
    result_int = frame + max_search_frames; // Default if no change is found, in original frame space (int)
    while(low_int <= high_int) {
        mid_int = low_int + (high_int - low_int) / 2;
        // Scale the mid frame (as float) before passing to base algorithm
        float mid_frame_float = float(mid_int) * frame_multiplier;
        float mid_val = _fpsr_sm_base(mid_frame_float, minHold, maxHold, reseedInterval, seedInner, seedOuter, finalRandSwitch);
        if (mid_val != out.randVal) {
            result_int = mid_int;
            next_val_candidate = mid_val; // Store the value at this frame
            high_int = mid_int - 1;
        } else {
            low_int = mid_int + 1;
        }
    }
    out.next_changed_frame = result_int;
    out.randVal_next_changed_frame = next_val_candidate;
    
    // Calculate hold progress based on scaled frame values
    // These calculations now also use float for precision before final cast
    float scaled_last_changed_frame_val_float = float(out.last_changed_frame) * frame_multiplier;
    float scaled_next_changed_frame_val_float = float(out.next_changed_frame) * frame_multiplier;
    float hold_duration_scaled_float = scaled_next_changed_frame_val_float - scaled_last_changed_frame_val_float;
    
    if (hold_duration_scaled_float > 0.0) {
        out.hold_progress = (current_scaled_frame_float - scaled_last_changed_frame_val_float) / hold_duration_scaled_float;
    } else {
        out.hold_progress = 0.0; // Handle zero duration to avoid division by zero
    }
    
    return out;
}

/**
 * @brief Wrapper for fpsr_tm that returns a detailed FPSR_Output struct.
 * @param frame (int) The current frame or time input.
 * @param frame_multiplier (float) A float value to scale the frame input, effectively speeding
 * up or slowing down the algorithm's internal timeline.
 * @param periodA (int) The first hold duration (in frames).
 * @param periodB (int) The second hold duration (in frames).
 * @param periodSwitch (int) The fixed interval at which the hold duration is toggled.
 * @param seedInner (int) An offset for the toggle clock to de-sync it from the main clock.
 * @param seedOuter (int) An offset for the main clock to create unique sequences.
 * @param finalRandSwitch (int) A flag that can turn off the final randomisation step.
 * @param lod (int) The level of detail to calculate.
 * @param max_search_frames (int) A safety limit for the backward/forward search to prevent infinite loops.
 * @return FPSR_Output struct with metadata populated based on the LOD.
 */
FPSR_Output fpsr_tm_get_details(
    int frame; float frame_multiplier; // Reordered frame_multiplier
    int periodA; int periodB;
    int periodSwitch; int seedInner; int seedOuter; int finalRandSwitch;
    int lod; int max_search_frames)
{
    FPSR_Output out;
    out.randVal = 0.0;
    out.has_changed = 0;
    out.hold_progress = 0.0;
    out.last_changed_frame = 0;
    out.next_changed_frame = 0;
    out.randVal_next_changed_frame = 0.0;
    out.randStreams[0] = 0.0;
    out.randStreams[1] = 0.0;
    out.selected_stream = 0;

    // Calculate the scaled frame input for the base algorithm (as float)
    float current_scaled_frame_float = float(frame) * frame_multiplier; // Cast frame to float for multiplication

    // LOD 0
    out.randVal = _fpsr_tm_base(current_scaled_frame_float, periodA, periodB, periodSwitch, seedInner, seedOuter, finalRandSwitch);
    
    if (lod < 1) return out;

    // LOD 1: Compare with previous frame to check for change.
    // Calculate the scaled frame input for the previous frame
    float prev_scaled_frame_for_lod1_float = float(frame - 1) * frame_multiplier;
    float prev_val = _fpsr_tm_base(prev_scaled_frame_for_lod1_float, periodA, periodB, periodSwitch, seedInner, seedOuter, finalRandSwitch);
    out.has_changed = (out.randVal != prev_val);
    
    if (lod < 2) return out;

    // LOD 2: Robust Search
    int low_int, high_int, mid_int, result_int;
    float next_val_candidate = 0.0; // Stores the value at the next_changed_frame

    // --- Backwards Search for last_changed_frame ---
    if (out.has_changed) {
        // Optimization: If has_changed == 1, assign last_changed_frame = frame.
        // Avoids 4 calls to _fpsr_xx_base(): (1 in exponential probe, 3 in binary search)
        // Avoids 3 loops iterations (1 in exponential probe, 2 in binary search)
        out.last_changed_frame = frame;
    } else {
        // Phase 1: Exponential probe to find a "dirty" region.
        int bound_low_int = frame; // operates on original frame space (int)
        int step_int = 1; // Used for exponential probe step
        while (frame - step_int > frame - max_search_frames) { // All int
            // Scale the probe frame (as float) before passing to base algorithm
            float probe_frame_float = float(frame - step_int) * frame_multiplier; // All float
            if (_fpsr_tm_base(probe_frame_float, periodA, periodB, periodSwitch, seedInner, seedOuter, finalRandSwitch) != out.randVal) {
                bound_low_int = frame - step_int;
                break;
            }
            bound_low_int = frame - step_int;
            step_int *= 2; // Changed to int
        }

        // Phase 2: Binary search within the safe, "dirty" region.
        low_int = bound_low_int;
        high_int = frame;
        result_int = frame; // result stores the original frame number (int)
        while(low_int <= high_int) {
            mid_int = low_int + (high_int - low_int) / 2; // All int
            // Scale the mid frame (as float) before passing to base algorithm
            float mid_frame_float = float(mid_int) * frame_multiplier; // All float
            if (_fpsr_tm_base(mid_frame_float, periodA, periodB, periodSwitch, seedInner, seedOuter, finalRandSwitch) == out.randVal) {
                // Check the frame immediately preceding 'mid' in the scaled timeline
                // using 1 as the step for comparison
                float mid_minus_step_frame_float = float(mid_int - 1) * frame_multiplier;
                if (_fpsr_tm_base(mid_minus_step_frame_float, periodA, periodB, periodSwitch, seedInner, seedOuter, finalRandSwitch) != out.randVal) {
                    result_int = mid_int; break;
                }
                high_int = mid_int - 1;
            } else {
                low_int = mid_int + 1;
            }
        }
        out.last_changed_frame = result_int;
    }

    // --- Forwards search ---
    // Phase 1: Exponential probe.
    int bound_high_int = frame; // operates on original frame space (int)
    step_int = 1; // Used for exponential probe step
    while (frame + step_int < frame + max_search_frames) { // All int
        // Scale the probe frame (as float) before passing to base algorithm
        float probe_frame_float = float(frame + step_int) * frame_multiplier; // All float
        float val_at_probe = _fpsr_tm_base(probe_frame_float, periodA, periodB, periodSwitch, seedInner, seedOuter, finalRandSwitch);
        if (val_at_probe != out.randVal) {
            bound_high_int = frame + step_int;
            next_val_candidate = val_at_probe; // Store the value at the first differing frame
            break;
        }
        bound_high_int = frame + step_int;
        step_int *= 2; // Changed to int
    }

    // Phase 2: Binary search.
    low_int = frame;
    high_int = bound_high_int;
    result_int = frame + max_search_frames; // Default if no change is found, in original frame space (int)
    while(low_int <= high_int) {
        mid_int = low_int + (high_int - low_int) / 2; // All int
        // Scale the mid frame (as float) before passing to base algorithm
        float mid_frame_float = float(mid_int) * frame_multiplier; // All float
        float mid_val = _fpsr_tm_base(mid_frame_float, periodA, periodB, periodSwitch, seedInner, seedOuter, finalRandSwitch);
        if (mid_val != out.randVal) {
            result_int = mid_int;
            next_val_candidate = mid_val; // Store the value at this frame
            high_int = mid_int - 1; // All int
        } else {
            low_int = mid_int + 1; // All int
        }
    }
    out.next_changed_frame = result_int;
    out.randVal_next_changed_frame = next_val_candidate;
    
    // Calculate hold progress based on scaled frame values
    // These calculations now also use float for precision before final cast
    float scaled_last_changed_frame_val_float = float(out.last_changed_frame) * frame_multiplier; // All float
    float scaled_next_changed_frame_val_float = float(out.next_changed_frame) * frame_multiplier; // All float
    float hold_duration_scaled_float = scaled_next_changed_frame_val_float - scaled_last_changed_frame_val_float;
    
    if (hold_duration_scaled_float > 0.0) { // Use float literal
        out.hold_progress = (current_scaled_frame_float - scaled_last_changed_frame_val_float) / hold_duration_scaled_float; // Cast final result to float
    } else {
        out.hold_progress = 0.0; // Handle zero duration to avoid division by zero
    }

    return out;
}

/**
 * @brief Wrapper for fpsr_qs that returns a detailed FPSR_Output struct.
 * @param frame (int) The current frame or time input.
 * @param frame_multiplier (float) A float value to scale the frame input, effectively speeding
 * up or slowing down the algorithm's internal timeline.
 * @param baseWaveFreq (float) The base frequency for the modulation wave of stream 1.
 * @param stream2FreqMult (float) A multiplier for the second stream's frequency.
 * @param quantLevelsMinMax (int[]) An array of two integers for the min and max quantisation levels.
 * @param streamsOffset (int[]) An array of two integers to offset the frame for each stream's sine wave.
 * @param quantOffsets (int[]) An array of two integers to offset the random quantisation selection for each stream.
 * @param streamSwitchDur (int) The number of frames after which the streams switch.
 * @param stream1QuantDur (int) The duration for which stream 1's random quantisation level is held.
 * @param stream2QuantDur (int) The duration for which stream 2's random quantisation level is held.
 * @param finalRandSwitch (int) A flag that can turn off the final randomisation step.
 * @param sine_lod_level (int) Level of detail for sine wave generation 
 * (0: direct sin(), 1-3: (100, 500, 1000 samples) LUTs, 4: (4096 samples) highest precision LUT).
 * @param lod (int) The level of detail to calculate.
 * @param max_search_frames (int) A safety limit for the backward/forward search to prevent infinite loops.
 * @return FPSR_Output struct with metadata populated based on the LOD.
 */
FPSR_Output fpsr_qs_get_details(
    int frame; float frame_multiplier; // Reordered frame_multiplier
    float baseWaveFreq; float stream2FreqMult;
    int quantLevelsMinMax[]; int streamsOffset[]; int quantOffsets[];
    int streamSwitchDur; int stream1QuantDur; int stream2QuantDur; int finalRandSwitch;
    int sine_lod_level; // New parameter for sine LOD
    int lod; int max_search_frames)
{
    FPSR_Output out;
    out.randVal = 0.0;
    out.has_changed = 0;
    out.hold_progress = 0.0;
    out.last_changed_frame = 0;
    out.next_changed_frame = 0;
    out.randVal_next_changed_frame = 0.0;
    out.randStreams[0] = 0.0;
    out.randStreams[1] = 0.0;
    out.selected_stream = 0;

    // Calculate the scaled frame input for the base algorithm (as float)
    float current_scaled_frame_float = float(frame) * frame_multiplier; // Cast frame to float for multiplication

    // LOD 0
    _FPSR_QS_Base_Output base_qs_output = _fpsr_qs_base(current_scaled_frame_float, baseWaveFreq, stream2FreqMult, quantLevelsMinMax, streamsOffset, quantOffsets, streamSwitchDur, stream1QuantDur, stream2QuantDur, finalRandSwitch, sine_lod_level);
    out.randVal = base_qs_output.randVal;
    out.randStreams[0] = base_qs_output.stream1_val;
    out.randStreams[1] = base_qs_output.stream2_val;
    out.selected_stream = base_qs_output.selected_stream_idx;

    if (lod < 1) return out;

    // LOD 1: Compare with previous frame to check for change.
    // Calculate the scaled frame input for the previous frame
    float prev_scaled_frame_for_lod1_float = float(frame - 1) * frame_multiplier;
    _FPSR_QS_Base_Output prev_qs_output = _fpsr_qs_base(prev_scaled_frame_for_lod1_float, baseWaveFreq, stream2FreqMult, quantLevelsMinMax, streamsOffset, quantOffsets, streamSwitchDur, stream1QuantDur, stream2QuantDur, finalRandSwitch, sine_lod_level);
    float prev_val = prev_qs_output.randVal;
    out.has_changed = (out.randVal != prev_val);
    
    if (lod < 2) return out;

    // LOD 2: Robust Search
    int low_int, high_int, mid_int, result_int;
    float next_val_candidate = 0.0; // Stores the value at the next_changed_frame

    // --- Backwards Search for last_changed_frame ---
    if (out.has_changed) {
        // Optimization: If has_changed == 1, assign last_changed_frame = frame.
        // Avoids 4 calls to _fpsr_xx_base(): (1 in exponential probe, 3 in binary search)
        // Avoids 3 loops iterations (1 in exponential probe, 2 in binary search)
        out.last_changed_frame = frame;
    } else {
        // Phase 1: Exponential probe to find a "dirty" region.
        int bound_low_int = frame; // operates on original frame space (int)
        int step_int = 1; // Used for exponential probe step
        while (frame - step_int > frame - max_search_frames) {
            // Scale the probe frame (as float) before passing to base algorithm
            float probe_frame_float = float(frame - step_int) * frame_multiplier;
            _FPSR_QS_Base_Output probe_qs_output = _fpsr_qs_base(probe_frame_float, baseWaveFreq, stream2FreqMult, quantLevelsMinMax, streamsOffset, quantOffsets, streamSwitchDur, stream1QuantDur, stream2QuantDur, finalRandSwitch, sine_lod_level);
            if (probe_qs_output.randVal != out.randVal) {
                bound_low_int = frame - step_int;
                break;
            }
            bound_low_int = frame - step_int;
            step_int *= 2;
        }
        
        // Phase 2: Binary search within the safe, "dirty" region.
        low_int = bound_low_int;
        high_int = frame;
        result_int = frame; // result stores the original frame number (int)
        while(low_int <= high_int) {
            mid_int = low_int + (high_int - low_int) / 2;
            // Scale the mid frame (as float) before passing to base algorithm
            float mid_frame_float = float(mid_int) * frame_multiplier;
            _FPSR_QS_Base_Output mid_qs_output = _fpsr_qs_base(mid_frame_float, baseWaveFreq, stream2FreqMult, quantLevelsMinMax, streamsOffset, quantOffsets, streamSwitchDur, stream1QuantDur, stream2QuantDur, finalRandSwitch, sine_lod_level);
            if (mid_qs_output.randVal == out.randVal) {
                // Check the frame immediately preceding 'mid' in the scaled timeline
                // using 1 as the step for comparison
                float mid_minus_step_frame_float = float(mid_int - 1) * frame_multiplier;
                _FPSR_QS_Base_Output mid_minus_step_qs_output = _fpsr_qs_base(mid_minus_step_frame_float, baseWaveFreq, stream2FreqMult, quantLevelsMinMax, streamsOffset, quantOffsets, streamSwitchDur, stream1QuantDur, stream2QuantDur, finalRandSwitch, sine_lod_level);
                if (mid_minus_step_qs_output.randVal != out.randVal) {
                    result_int = mid_int; break;
                }
                high_int = mid_int - 1;
            } else {
                low_int = mid_int + 1;
            }
        }
        out.last_changed_frame = result_int;
    }

    // --- Forwards search ---
    // Phase 1: Exponential probe.
    int bound_high_int = frame; // operates on original frame space (int)
    step_int = 1; // Used for exponential probe step
    while (frame + step_int < frame + max_search_frames) {
        // Scale the probe frame (as float) before passing to base algorithm
        float probe_frame_float = float(frame + step_int) * frame_multiplier;
        _FPSR_QS_Base_Output probe_qs_output = _fpsr_qs_base(probe_frame_float, baseWaveFreq, stream2FreqMult, quantLevelsMinMax, streamsOffset, quantOffsets, streamSwitchDur, stream1QuantDur, stream2QuantDur, finalRandSwitch, sine_lod_level);
        if (probe_qs_output.randVal != out.randVal) {
            bound_high_int = frame + step_int;
            next_val_candidate = probe_qs_output.randVal; // Store the value at the first differing frame
            break;
        }
        bound_high_int = frame + step_int;
        step_int *= 2;
    }

    // Phase 2: Binary search.
    low_int = frame;
    high_int = bound_high_int;
    result_int = frame + max_search_frames; // Default if no change is found, in original frame space (int)
    while(low_int <= high_int) {
        mid_int = low_int + (high_int - low_int) / 2;
        // Scale the mid frame (as float) before passing to base algorithm
        float mid_frame_float = float(mid_int) * frame_multiplier;
        _FPSR_QS_Base_Output mid_qs_output = _fpsr_qs_base(mid_frame_float, baseWaveFreq, stream2FreqMult, quantLevelsMinMax, streamsOffset, quantOffsets, streamSwitchDur, stream1QuantDur, stream2QuantDur, finalRandSwitch, sine_lod_level);
        if (mid_qs_output.randVal != out.randVal) {
            result_int = mid_int;
            next_val_candidate = mid_qs_output.randVal; // Store the value at this frame
            high_int = mid_int - 1;
        } else {
            low_int = mid_int + 1;
        }
    }
    out.next_changed_frame = result_int;
    
    // Calculate hold progress based on scaled frame values
    // These calculations now also use float for precision before final cast
    float scaled_last_changed_frame_val_float = float(out.last_changed_frame) * frame_multiplier;
    float scaled_next_changed_frame_val_float = float(out.next_changed_frame) * frame_multiplier;
    float hold_duration_scaled_float = scaled_next_changed_frame_val_float - scaled_last_changed_frame_val_float;
    
    if (hold_duration_scaled_float > 0.0) {
        out.hold_progress = (current_scaled_frame_float - scaled_last_changed_frame_val_float) / hold_duration_scaled_float;
    } else {
        out.hold_progress = 0.0; // Handle zero duration to avoid division by zero
    }

    out.randVal_next_changed_frame = next_val_candidate;

    return out;
}

